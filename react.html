<!DOCTYPE html>
<html>
<head>
    <title>Udacity Todos Goals</title>
    <!-- This will download the real Redux library and give it a global namespace as `Redux` 
    So anywhere we want to access redux inside of our app, we wil use this global namespace -->
     <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
    <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script> <!-- react -->
    <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script> <!-- react-dom -->
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script> <!-- compiles our jsx code into normal js code-->
    <!-- We're simulating the fake database to keep that aspect of the project less complex. Adding this file will add a property to the global window object namespace called
    API(so we have window.API). so now we can inovoke eg API.fetchGoals ...etc. The methods we haveaccess to are 
     API{ fetchGoals: ƒ, fetchTodos: ƒ, saveTodo: ƒ, saveGoal: ƒ, saveTodoToggle: ƒ, deleteGoal: ƒ, deleteTodo: ƒ } -->
    <script src="https://ui.dev/goals-todos-api/index.js"></script>
    <script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script> <!-- redux-thunk library-->
</head>
<body>
    <div id='app'></div>

    <script type='text/javascript'>
        function generateId () {
          return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
        }
    
        // App Code
        const ADD_TODO = 'ADD_TODO'
        const REMOVE_TODO = 'REMOVE_TODO'
        const TOGGLE_TODO = 'TOGGLE_TODO'
        const ADD_GOAL = 'ADD_GOAL'
        const REMOVE_GOAL = 'REMOVE_GOAL'
        const RECEIVE_DATA = 'RECEIVE_DATA'
    
        function addTodoAction (todo) {
          return {
            type: ADD_TODO,
            todo,
          }
        }
    
        function removeTodoAction (id) {
          return {
            type: REMOVE_TODO,
            id,
          }
        }

        /*We have a function that can be passed in a dispatch
        
        This function returns dispatch dispatch method */
        function handleDeleteTodo (todo) {

            return (dispatch) => {
                //this.props.store.dispatch(removeTodoAction(todo.id))  //if we had our API call inside our UI code at removeItem in Todo component, we use this.store.props but now our middleware will call this function for us from the store it already posesses
                dispatch(removeTodoAction(todo.id))

                return API.deleteTodo(todo.id)
                /* The reason we do not want to wait for the server. Because sometimes there might be a delay.
                You dont want the delay to reflect in your UI 
                .then(() => {
                    this.props.store.dispatch(removeGoalAction(goal.id))
                })*/
                /* check this link if you want to use fully convert this handleDeleteTodo method to b asycnhronous which it should be
                so that you can use async/await 
                https://jonathangrosdubois.medium.com/the-myth-of-evil-for-loops-and-try-catch-blocks-in-javascript-8601860295c1 */
                .catch(() => {
                    //this.props.store.dispatch(addTodoAction(todo)) //if we had our API call inside our UI code at removeItem in Todo component, we use this.store.props but now our middleware will call this function for us from the store it already posesses
                    dispatch(addTodoAction(todo)) //we add the item back to the list if there is an error
                    alert('An error occurred. Try again.')
                })
            }
        }

        /*
        The code below executes in this order
        - The API request occurs first
        - The API request is resolved
        - Thunk middleware invokes the function with dispatch()
        - The action returned by the receiveTodos is dispatched
        
        in your project make this function async like
        const handleDeleteGoal = async (goal) => (dispatch) => {} then you can use try/catch as well was await
        like
        try {
            const goal = await API.saveGoal(name);
            dispatch(addGoalAction(goal))
            cb()
        } catch (error) {
            console.log('ERROR!', error);
            alert('There was an error. Try again.')
        }
        https://jonathangrosdubois.medium.com/the-myth-of-evil-for-loops-and-try-catch-blocks-in-javascript-8601860295c1
        */
        const handleAddGoal = (name, cb) => (dispatch) => {
            API.saveGoal(name)
            .then((goal) => {
                dispatch(addGoalAction(goal))
                cb() //used to set the input filed to be empty
            })
            .catch(() => alert('There was an error. Try again.'))
        }

        /*
        The code below executes in this order
        -Thunk middleware invokes the first function with dispatch()
        - The action returned by the removeGoalAction is dispatched
        - The API request occurs first
        - The API request is resolved
        **** if the API fails we rollback the previous action made to the state** know as optimistic update
        - Thunk middleware invokes the second function with dispatch()
        - The action returned by the addGoalAction is dispatched */
        const handleDeleteGoal = (goal) => (dispatch) => {

            dispatch(removeGoalAction(goal.id))
            
            API.deleteGoal(goal.id)
            .catch(() => {
                dispatch(addGoalAction(goal))
                alert('An error occurred. Try again.')
            })
        }
    
        function toggleTodoAction (id) {
          return {
            type: TOGGLE_TODO,
            id,
          }
        }
    
        function addGoalAction (goal) {
          return {
            type: ADD_GOAL,
            goal,
          }
        }
    
        function removeGoalAction (id) {
          return {
            type: REMOVE_GOAL,
            id,
          }
        }

        function receiveDataAction (todos, goals) {
            return {
                type: RECEIVE_DATA,
                todos,
                goals,
            }
        }
    
        function todos (state = [], action) {
          switch(action.type) {
            case ADD_TODO :
              return state.concat([action.todo])
            case REMOVE_TODO :
              return state.filter((todo) => todo.id !== action.id)
            case TOGGLE_TODO :
              return state.map((todo) => todo.id !== action.id ? todo :
                Object.assign({}, todo, { complete: !todo.complete }))
            case RECEIVE_DATA : //at this point, the state will be an empty array, so instead of returning an empty array, we will return the todos action payload which is directly from the API
                return action.todos
            default :
              return state
          }
        }
    
        function goals (state = [], action) {
          switch(action.type) {
            case ADD_GOAL :
              return state.concat([action.goal])
            case REMOVE_GOAL :
              return state.filter((goal) => goal.id !== action.id)
            case RECEIVE_DATA :
                return action.goals
            default :
              return state
          }
        }

        /*
        REMEMBER: reducer always receives a state and action then returns a new state. And also reducers must be pure functions
        */
        function loading (state = true, action) {
            console.log(action.type)
            switch(action.type) {
                case RECEIVE_DATA : //we already had the action type in todos and goals reducers that we wanted to listen for
                    return false //we update the loading state of our store to false
                default :
                return state
            }
        }

    
        const checker = (store) => (next) => (action) => {
          if (
            action.type === ADD_TODO &&
            action.todo.name.toLowerCase().includes('bitcoin')
          ) {
            return alert("Nope. That's a bad idea.")
          }
    
          if (
            action.type === ADD_GOAL &&
            action.goal.name.toLowerCase().includes('bitcoin')
          ) {
            return alert("Nope. That's a bad idea.")
          }
    
          return next(action)
        }

        /*We create a cutsom middleware in order to support the functionality in handleDeleteTodo() method
        This middleware is so common that we dont need to wirte our own thunk code and include in in the middleware by .applyMiddleware(thunk), we could just use 
        ReduxThunk.default, the official Redux thunk package from the library in  by calling .applyMiddleware(ReduxThunk.default) which we did
        It is good to know though ;) */
        const thunk = (store) => (next) => (action) => {
            if (typeof action === 'function') {  //if the action retured by handleDeleteTodo() is a function
                return action(store.dispatch)
            }
            return next(action)
        }
    
        const logger = (store) => (next) => (action) => {
          console.group(action.type)
            console.log('The action: ', action)
            const result = next(action)
            console.log('The new state: ', store.getState())
          console.groupEnd()
          return result
        }
    
        const store = Redux.createStore(Redux.combineReducers({
          todos,
          goals,
          //What happens is calling cretaeStrore, other slices of state tree(todos & goals) will have default value of [] while isloading will have default value of `true`
          loading, //added the brand new reducer to our store. Each reducer you add, ass a new slice of state to manage to the state tree
        }), Redux.applyMiddleware(checker, logger, ReduxThunk.default))
    
        /*
        With React we dont have to do any of these DOM operations because React does that for us
        it is one of the good thing about using React
        store.subscribe(() => {
          const { goals, todos } = store.getState()
    
          //document.getElementById('goals').innerHTML = ''
          //document.getElementById('todos').innerHTML = ''
    
          //goals.forEach(addGoalToDOM)
          //todos.forEach(addTodoToDOM)
        })*/
    
        // DOM code
        /*
        We dont need any of the dom code anymore we have them inside of our React components
        function addTodo () {
          const input = document.getElementById('todo')
          const name = input.value
          input.value = ''
    
          store.dispatch(addTodoAction({
            name,
            complete: false,
            id: generateId()
          }))
        }
    
        function addGoal () {
          const input = document.getElementById('goal')
          const name = input.value
          input.value = ''
    
          store.dispatch(addGoalAction({
            id: generateId(),
            name,
          }))
        }*/
    
    </script>
    <!-- This lets the compiler to knw when we have babel script code to run-->
    <script type='text/babel'> 
        function List (props) {
          return (
            <ul>
                {props.items.map((item) => (
                    <li key={item.id}>
                        <span 
                        onClick={/* due to this is an optional parameter, we check if props.toggle is passed
                            then we invoke the toggle function which will cause a re-render to the Ui with the updated state*/
                        () => props.toggle && props.toggle(item.id)}
                        style={{textDecoration: item.complete ? 'line-through' : 'none'}}
                        >
                        {item.name}</span>
                        <button onClick={() => props.remove(item)}>
                            X
                        </button>
                    </li>
                ))}
            </ul>
          )
        }
    
        class Todos extends React.Component {
            
            addItem = (e) => {

                e.preventDefault()
                const name = this.todoInput.value //we can easily reference this.input with arrow functions here because we assigned an input property to the global this within this component
                this.todoInput.value = ''
                
                //the store was passed as props from the parent, the App Component. We will still break this props down into separete modules later
                //but passing it as props for now makes it easier for refactoring later
                this.props.store.dispatch(addTodoAction({
                    name,
                    complete: false,
                    id: generateId()
                }))
            }

            removeItem = (todo) => {

                //Now we just have UI logic. We moved the API logic to an asynchronous function the returns a promise
                this.props.store.dispatch(handleDeleteTodo(todo))
            }

            toggleItem = (id) => {
                this.props.store.dispatch(toggleTodoAction(id))
            }

          render() {
            return (
              <div>
                <h1>Todo List</h1>
                <input
                type='text'
                placeholder='Add Todo'
                ref={ /*
                    inputElement is a reference to the input DOM element. We are storing a reference to the input DOM element
                    in the todoInput instance property of the Todos class.
                    Remeber With arrow functions, the value of "this" is based on the function's surrounding context 
                    (where the function is located in the code). In other words, the value of this inside an arrow function 
                    is the same as the value of this outside the function.

                    Instead of sticking the value of this input field on our Component state to make it controlled,
                    We added a ref and stick this ref on this component instance. So whenever, we want
                    to grap the value of the input, we will grap it from 'this.todoInput'

                    for more on when to use refs cehck here https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
                    */
                    (inputElement) => this.todoInput = inputElement}
                />
                <button onClick={this.addItem}>Add Todo</button>
    
                <List items={this.props.todos} remove={this.removeItem}/>
              </div>
            )
          }
        }
    
        class Goals extends React.Component {

            addItem = (e) => {
                e.preventDefault()
                this.props.store.dispatch(handleAddGoal(
                    this.input.value,
                    () => this.input.value = '' //invoking this callback function will set this input field to empty
                    ))

                /*const name = this.input.value
                this.input.value = ''

                this.props.store.dispatch(addGoalAction({
                    id: generateId(),
                    name,
                }))*/
            }

            removeItem = (goal) => {

                this.props.store.dispatch(handleDeleteGoal(goal))

                /*this.props.store.dispatch(removeGoalAction(goal.id))

                return API.deleteGoal(goal.id)
                .catch(() => {
                    this.props.store.dispatch(addGoalAction(goal))
                    alert('An error occurred. Try again.')
                })*/
            }

          render() {
            return (
              <div>
                <h1>Goals</h1>
                <input
                type='text'
                placeholder='Add Goal'
                ref={(input) => this.input = input}
                />
                <button onClick={this.addItem}>Add Goal</button>
    
                <List items={this.props.goals} remove={this.removeItem}/>
              </div>
            )
          }
        }
    
        class App extends React.Component {

            componentDidMount () {
                const { store } = this.props
                
                store.subscribe(() => this.forceUpdate()) //forceUpdate is an anti-pattern in React. We rearly use it but it works

                //Promise.all() to wait until all Promises have resolved before displaying the content to the user.
                //more on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
                Promise.all([
                    API.fetchTodos(),
                    API.fetchGoals()
                ]).then(([ todos, goals ]) => {
                    //console.log('Todos', todos)
                    //console.log('Goals', goals)
                    store.dispatch(receiveDataAction(todos, goals))
                })
            }

          render() {

            /*Whenever the forceUpdate gets called we will re-render this component. This is rarely used to re-render components but for our case right here, it fits
            because we dont have a state inside of the App component and it does not make sense to any any just to cause a re-render
            Most of the times, we use this.setState to re-render the UI wheich we are use to*/
            const { store } = this.props
            const { todos, goals, loading } = store.getState() //get the slices of the state tree and pass them down as props to the individual component that needs them which will eventually used to render a list of todos and goals

            if (loading === true) {
                return <h3>Loading</h3>
            }

            return (
              <div>
                <Todos todos={todos} store={/*we get the store props passed to our app component and pass it down to the Todo component*/
                    this.props.store}/>
                <Goals goals={goals} store={this.props.store}/>
              </div>
            )
          }
        }
    
        ReactDOM.render(
          <App store={/*Ideally, we will have our store with the actions and reducers in 
            another file(we will have all the code in <text/javascript> at another file) and we will import it as prop to our app. 
            This way, we are maintaining our state from one place which is the purpose of using Redux*/
              store}/>,
          document.getElementById('app')
        )
      </script>
</body>
</html>