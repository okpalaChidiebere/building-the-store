<!DOCTYPE html>
<html>
<head>
    <title>Udacity Todos Goals</title>
    <!-- This will download the real Redux library and give it a global namespace as `Redux` 
    So anywhere we want to access redux inside of our app, we wil use this global namespace -->
     <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
    <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script> <!-- react -->
    <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script> <!-- react-dom -->
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script> <!-- compiles our jsx code into normal js code-->
    <!-- We're simulating the fake database to keep that aspect of the project less complex. Adding this file will add a property to the global window object namespace called
    API(so we have window.API). so now we can inovoke eg API.fetchGoals ...etc. The methods we haveaccess to are 
     API{ fetchGoals: ƒ, fetchTodos: ƒ, saveTodo: ƒ, saveGoal: ƒ, saveTodoToggle: ƒ, deleteGoal: ƒ, deleteTodo: ƒ } -->
    <script src="https://ui.dev/goals-todos-api/index.js"></script>
    <script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script> <!-- redux-thunk library-->
</head>
<body>
    <div id='app'></div>

    <script type='text/javascript'>
        function generateId () {
          return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
        }
    
        // App Code
        const ADD_TODO = 'ADD_TODO'
        const REMOVE_TODO = 'REMOVE_TODO'
        const TOGGLE_TODO = 'TOGGLE_TODO'
        const ADD_GOAL = 'ADD_GOAL'
        const REMOVE_GOAL = 'REMOVE_GOAL'
        const RECEIVE_DATA = 'RECEIVE_DATA'
    
        function addTodoAction (todo) {
          return {
            type: ADD_TODO,
            todo,
          }
        }
    
        function removeTodoAction (id) {
          return {
            type: REMOVE_TODO,
            id,
          }
        }

        /*We have a function that can be passed in a dispatch
        
        This function returns dispatch dispatch method */
        function handleDeleteTodo (todo) {

            return (dispatch) => {
                //this.props.store.dispatch(removeTodoAction(todo.id))  //if we had our API call inside our UI code at removeItem in Todo component, we use this.store.props but now our middleware will call this function for us from the store it already posesses
                dispatch(removeTodoAction(todo.id))

                return API.deleteTodo(todo.id)
                /* The reason we do not want to wait for the server. Because sometimes there might be a delay.
                You dont want the delay to reflect in your UI 
                .then(() => {
                    this.props.store.dispatch(removeGoalAction(goal.id))
                })*/
                /* check this link if you want to use fully convert this handleDeleteTodo method to b asycnhronous which it should be
                so that you can use async/await 
                https://jonathangrosdubois.medium.com/the-myth-of-evil-for-loops-and-try-catch-blocks-in-javascript-8601860295c1 */
                .catch(() => {
                    //this.props.store.dispatch(addTodoAction(todo)) //if we had our API call inside our UI code at removeItem in Todo component, we use this.store.props but now our middleware will call this function for us from the store it already posesses
                    dispatch(addTodoAction(todo)) //we add the item back to the list if there is an error
                    alert('An error occurred. Try again.')
                })
            }
        }

        /*
        The code below executes in this order
        - The API request occurs first
        - The API request is resolved
        - Thunk middleware invokes the function with dispatch()
        - The action returned by the receiveTodos is dispatched
        
        in your project make this function async like
        const handleDeleteGoal = async (goal) => (dispatch) => {} then you can use try/catch as well was await
        like
        try {
            const goal = await API.saveGoal(name);
            dispatch(addGoalAction(goal))
            cb()
        } catch (error) {
            console.log('ERROR!', error);
            alert('There was an error. Try again.')
        }
        https://jonathangrosdubois.medium.com/the-myth-of-evil-for-loops-and-try-catch-blocks-in-javascript-8601860295c1
        */
        const handleAddGoal = (name, cb) => (dispatch) => {
            API.saveGoal(name)
            .then((goal) => {
                dispatch(addGoalAction(goal))
                cb() //used to set the input filed to be empty
            })
            .catch(() => alert('There was an error. Try again.'))
        }

        /*
        The code below executes in this order
        -Thunk middleware invokes the first function with dispatch()
        - The action returned by the removeGoalAction is dispatched
        - The API request occurs first
        - The API request is resolved
        **** if the API fails we rollback the previous action made to the state** know as optimistic update
        - Thunk middleware invokes the second function with dispatch()
        - The action returned by the addGoalAction is dispatched */
        const handleDeleteGoal = (goal) => (dispatch) => {

            dispatch(removeGoalAction(goal.id))
            
            API.deleteGoal(goal.id)
            .catch(() => {
                dispatch(addGoalAction(goal))
                alert('An error occurred. Try again.')
            })
        }

        const handleAddTodo = (name, cb) => (dispatch) => {

            API.saveTodo(name)
            .then((todo) => {
                dispatch(addTodoAction(todo))
                cb()
            })
            .catch(() => {
                alert('There was an error. Try again.')
            })
        }

        const handleToggle = (id) => (dispatch) => {

            dispatch(toggleTodoAction(id))
            API.saveTodoToggle(id)
            .catch(() => {
                dispatch(toggleTodoAction(id))
                alert('An error occurred. Try again.')
            })
        }

        /**
         * Rememeber handlers are also Action creators
         */
        const handleInitialData = () => (dispatch) => {

            //Promise.all() to wait until all Promises have resolved before displaying the content to the user.
            //more on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
            Promise.all([
                API.fetchTodos(),
                API.fetchGoals()
            ]).then(([ todos, goals ]) => {
                dispatch(receiveDataAction(todos, goals))
            })
        }

        function toggleTodoAction (id) {
          return {
            type: TOGGLE_TODO,
            id,
          }
        }
    
        function addGoalAction (goal) {
          return {
            type: ADD_GOAL,
            goal,
          }
        }
    
        function removeGoalAction (id) {
          return {
            type: REMOVE_GOAL,
            id,
          }
        }

        function receiveDataAction (todos, goals) {
            return {
                type: RECEIVE_DATA,
                todos,
                goals,
            }
        }
    
        function todos (state = [], action) {
          switch(action.type) {
            case ADD_TODO :
              return state.concat([action.todo])
            case REMOVE_TODO :
              return state.filter((todo) => todo.id !== action.id)
            case TOGGLE_TODO :
              return state.map((todo) => todo.id !== action.id ? todo :
                Object.assign({}, todo, { complete: !todo.complete }))
            case RECEIVE_DATA : //at this point, the state will be an empty array, so instead of returning an empty array, we will return the todos action payload which is directly from the API
                return action.todos
            default :
              return state
          }
        }
    
        function goals (state = [], action) {
          switch(action.type) {
            case ADD_GOAL :
              return state.concat([action.goal])
            case REMOVE_GOAL :
              return state.filter((goal) => goal.id !== action.id)
            case RECEIVE_DATA :
                return action.goals
            default :
              return state
          }
        }

        /*
        REMEMBER: reducer always receives a state and action then returns a new state. And also reducers must be pure functions
        */
        function loading (state = true, action) {
            console.log(action.type)
            switch(action.type) {
                case RECEIVE_DATA : //we already had the action type in todos and goals reducers that we wanted to listen for
                    return false //we update the loading state of our store to false
                default :
                return state
            }
        }

    
        const checker = (store) => (next) => (action) => {
          if (
            action.type === ADD_TODO &&
            action.todo.name.toLowerCase().includes('bitcoin')
          ) {
            return alert("Nope. That's a bad idea.")
          }
    
          if (
            action.type === ADD_GOAL &&
            action.goal.name.toLowerCase().includes('bitcoin')
          ) {
            return alert("Nope. That's a bad idea.")
          }
    
          return next(action)
        }

        /*We create a cutsom middleware in order to support the functionality in handleDeleteTodo() method
        This middleware is so common that we dont need to wirte our own thunk code and include in in the middleware by .applyMiddleware(thunk), we could just use 
        ReduxThunk.default, the official Redux thunk package from the library in  by calling .applyMiddleware(ReduxThunk.default) which we did
        It is good to know though ;) */
        const thunk = (store) => (next) => (action) => {
            if (typeof action === 'function') {  //if the action retured by handleDeleteTodo() is a function
                return action(store.dispatch)
            }
            return next(action)
        }
    
        const logger = (store) => (next) => (action) => {
          console.group(action.type)
            console.log('The action: ', action)
            const result = next(action)
            console.log('The new state: ', store.getState())
          console.groupEnd()
          return result
        }
    
        const store = Redux.createStore(Redux.combineReducers({
          todos,
          goals,
          //What happens is calling cretaeStrore, other slices of state tree(todos & goals) will have default value of [] while isloading will have default value of `true`
          loading, //added the brand new reducer to our store. Each reducer you add, ass a new slice of state to manage to the state tree
        }), Redux.applyMiddleware(checker, logger, ReduxThunk.default))
    
        /*
        With React we dont have to do any of these DOM operations because React does that for us
        it is one of the good thing about using React
        store.subscribe(() => {
          const { goals, todos } = store.getState()
    
          //document.getElementById('goals').innerHTML = ''
          //document.getElementById('todos').innerHTML = ''
    
          //goals.forEach(addGoalToDOM)
          //todos.forEach(addTodoToDOM)
        })*/
    
        // DOM code
        /*
        We dont need any of the dom code anymore we have them inside of our React components
        function addTodo () {
          const input = document.getElementById('todo')
          const name = input.value
          input.value = ''
    
          store.dispatch(addTodoAction({
            name,
            complete: false,
            id: generateId()
          }))
        }
    
        function addGoal () {
          const input = document.getElementById('goal')
          const name = input.value
          input.value = ''
    
          store.dispatch(addGoalAction({
            id: generateId(),
            name,
          }))
        }*/
    
    </script>
    <!-- This lets the compiler to knw when we have babel script code to run-->
    <script type='text/babel'> 
        function List (props) {
          return (
            <ul>
                {props.items.map((item) => (
                    <li key={item.id}>
                        <span 
                        onClick={/* due to this is an optional parameter, we check if props.toggle is passed
                            then we invoke the toggle function which will cause a re-render to the Ui with the updated state*/
                        () => props.toggle && props.toggle(item.id)}
                        style={{textDecoration: item.complete ? 'line-through' : 'none'}}
                        >
                        {item.name}</span>
                        <button onClick={() => props.remove(item)}>
                            X
                        </button>
                    </li>
                ))}
            </ul>
          )
        }
    
        class Todos extends React.Component {
            
            addItem = (e) => {

                e.preventDefault()

                this.props.dispatch(handleAddTodo(
        	        this.todoInput.value,
                    () => this.todoInput.value = ''
                ))
                /*const name = this.todoInput.value //we can easily reference this.input with arrow functions here because we assigned an input property to the global this within this component
                this.todoInput.value = ''
                
                //the store was passed as props from the parent, the App Component. We will still break this props down into separete modules later
                //but passing it as props for now makes it easier for refactoring later
                this.props.store.dispatch(addTodoAction({
                    name,
                    complete: false,
                    id: generateId()
                }))*/
            }

            removeItem = (todo) => {

                //Now we just have UI logic. We moved the API logic to an asynchronous function the returns a promise
                this.props.dispatch(handleDeleteTodo(todo))
            }

            toggleItem = (id) => {
                this.props.dispatch(handleToggle(id))
                //this.props.store.dispatch(toggleTodoAction(id))
            }

          render() {
            return (
              <div>
                <h1>Todo List</h1>
                <input
                type='text'
                placeholder='Add Todo'
                ref={ /*
                    inputElement is a reference to the input DOM element. We are storing a reference to the input DOM element
                    in the todoInput instance property of the Todos class.
                    Remeber With arrow functions, the value of "this" is based on the function's surrounding context 
                    (where the function is located in the code). In other words, the value of this inside an arrow function 
                    is the same as the value of this outside the function.

                    Instead of sticking the value of this input field on our Component state to make it controlled,
                    We added a ref and stick this ref on this component instance. So whenever, we want
                    to grap the value of the input, we will grap it from 'this.todoInput'

                    for more on when to use refs cehck here https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
                    */
                    (inputElement) => this.todoInput = inputElement}
                />
                <button onClick={this.addItem}>Add Todo</button>
    
                <List items={this.props.todos} remove={this.removeItem} toggle={this.toggleItem}/>
              </div>
            )
          }
        }

        class ConnectedTodos extends React.Component {
            render() {
                return (
                    <Context.Consumer>
                    {(store) => {
                        const { todos } = store.getState()

                        return <Todos todos={todos} dispatch={store.dispatch} />
                    }}
                    </Context.Consumer>
                )
            }
        }
    
        class Goals extends React.Component {

            addItem = (e) => {
                e.preventDefault()
                this.props.dispatch(handleAddGoal(
                    this.input.value,
                    () => this.input.value = '' //invoking this callback function will set this input field to empty
                    ))

                /*const name = this.input.value
                this.input.value = ''

                this.props.store.dispatch(addGoalAction({
                    id: generateId(),
                    name,
                }))*/
            }

            removeItem = (goal) => {

                this.props.dispatch(handleDeleteGoal(goal))

                /*this.props.store.dispatch(removeGoalAction(goal.id))

                return API.deleteGoal(goal.id)
                .catch(() => {
                    this.props.store.dispatch(addGoalAction(goal))
                    alert('An error occurred. Try again.')
                })*/
            }

          render() {
            return (
              <div>
                <h1>Goals</h1>
                <input
                type='text'
                placeholder='Add Goal'
                ref={(input) => this.input = input}
                />
                <button onClick={this.addItem}>Add Goal</button>
    
                <List items={this.props.goals} remove={this.removeItem}/>
              </div>
            )
          }
        }

        /*You need to know what information it needs from the store before you implement its Container Component
        Looking at the existing Goals component, it needs the dispatch and goals (Basically to know them them they are props usually in props for that component when you use Redux for your app
        Because redux makes you manages states for your app from one place and pass the store as props to the components that needs them. Howevern now we use React Context they will no longer use passed down as props)
        So insead of having <Goals goals={goals} store={this.props.store}/> in render method for Apps we now will have <ConnectedGoals />
        We also change the way we call the state inside the Goals Component it self too. We remove the .store*/
        class ConnectedGoals extends React.Component {
            render() {
                return (
                    <Context.Consumer>
                    {(store) => {
                        const { goals } = store.getState()

                        return <Goals goals={goals} dispatch={store.dispatch} />
                    }}
                    </Context.Consumer>
                )
            }
        }
    
        class App extends React.Component {

            componentDidMount () {
                const { store } = this.props
                
                store.subscribe(() => this.forceUpdate()) //forceUpdate is an anti-pattern in React. We rearly use it but it works

                store.dispatch(handleInitialData())

                
                /*Promise.all([
                    API.fetchTodos(),
                    API.fetchGoals()
                ]).then(([ todos, goals ]) => {
                    //console.log('Todos', todos)
                    //console.log('Goals', goals)
                    store.dispatch(receiveDataAction(todos, goals))
                })*/
            }

          render() {

            /*Whenever the forceUpdate gets called we will re-render this component. This is rarely used to re-render components but for our case right here, it fits
            because we dont have a state inside of the App component and it does not make sense to any any just to cause a re-render
            Most of the times, we use this.setState to re-render the UI wheich we are use to*/
            const { store } = this.props
            /*We no longer need to pass the todos and goals slice of the store down as prop.
            Uisng the ContainerComponent pattern helps solves this
            */ 
            const { loading } = store.getState() //get the slices of the state tree and pass them down as props to the individual component that needs them which will eventually used to render a list of todos and goals

            if (loading === true) {
                return <h3>Loading</h3>
            }

            return (
              <div>
                <ConnectedTodos />
                <ConnectedGoals />
              </div>
            )
          }
        }

        /*
        This component is connected to the store. This component is only responsible for interacting with the store. 
        Anything to do with the store and the data is done in the connected component
        So in our case, we grab the store of the context and then pass it to the APP component
        This helps us solve the problem that we have in APP component where need access to the store inside componentDidMount and render methods respectively
        So using this Connect or Container Component pattern helps us
        */
        class ConnectedApp extends React.Component {
            render() {
                return (
                <Context.Consumer>
                {(store) => (
                    <App store={store} />
                )}
                </Context.Consumer>
                )
            }
        }

        //create a Context object that has a Provider property as well as Consumer property
        const Context = React.createContext()

        /*We create a little abstraction of the provider ourselves by creating our Provider Component*/
        class Provider extends React.Component {
            render () {
                return (
                    <Context.Provider value={/*Any child component that use consumer can go ahead and consume our store withoud needing to pass it down as a prop*/
                        this.props.store}>
                        {this.props.children}
                    </Context.Provider>
                )
            }
        }
    
        ReactDOM.render(
            <Provider store={/*We only pass the store as prop here and any of the child components can grap the store without calling props
                <Provider>
                    <App>
                        <Context.Consumer>
                            {(store) => ()}
                        </Context.Consumer>
                    </App>
                </Provider>
                But instead of passing app down directly, we created a container implemented a ConnectedCOmponent pattern. It looks like this
                <ConnectedComponent>
                    <PresentationalComponent>
                            {(store) => ()}
                    </PresentationalComponent>
                </ConnectedComponent>
                - Connected Component: This component is connected to the store. This component is only responsible for interacting with the store. 
                Anything to do with the store and the data is done in the connected component
                - Presentational Component: This is just responsible for rendering content. 
                So, it concerned with how things look. Anything that have to do with something to render
                */
                store}>
                <ConnectedApp />
            </Provider>,
          document.getElementById('app')
        )
      </script>
</body>
</html>