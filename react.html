<!DOCTYPE html>
<html>
<head>
    <title>Udacity Todos Goals</title>
    <!-- This will download the real Redux library and give it a global namespace as `Redux` 
    So anywhere we want to access redux inside of our app, we wil use this global namespace -->
     <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
    <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script> <!-- react -->
    <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script> <!-- react-dom -->
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script> <!-- compiles our jsx code into normal js code-->
</head>
<body>
    <div id='app'></div>

    <script type='text/javascript'>
        function generateId () {
          return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
        }
    
        // App Code
        const ADD_TODO = 'ADD_TODO'
        const REMOVE_TODO = 'REMOVE_TODO'
        const TOGGLE_TODO = 'TOGGLE_TODO'
        const ADD_GOAL = 'ADD_GOAL'
        const REMOVE_GOAL = 'REMOVE_GOAL'
    
        function addTodoAction (todo) {
          return {
            type: ADD_TODO,
            todo,
          }
        }
    
        function removeTodoAction (id) {
          return {
            type: REMOVE_TODO,
            id,
          }
        }
    
        function toggleTodoAction (id) {
          return {
            type: TOGGLE_TODO,
            id,
          }
        }
    
        function addGoalAction (goal) {
          return {
            type: ADD_GOAL,
            goal,
          }
        }
    
        function removeGoalAction (id) {
          return {
            type: REMOVE_GOAL,
            id,
          }
        }
    
        function todos (state = [], action) {
          switch(action.type) {
            case ADD_TODO :
              return state.concat([action.todo])
            case REMOVE_TODO :
              return state.filter((todo) => todo.id !== action.id)
            case TOGGLE_TODO :
              return state.map((todo) => todo.id !== action.id ? todo :
                Object.assign({}, todo, { complete: !todo.complete }))
            default :
              return state
          }
        }
    
        function goals (state = [], action) {
          switch(action.type) {
            case ADD_GOAL :
              return state.concat([action.goal])
            case REMOVE_GOAL :
              return state.filter((goal) => goal.id !== action.id)
            default :
              return state
          }
        }
    
        const checker = (store) => (next) => (action) => {
          if (
            action.type === ADD_TODO &&
            action.todo.name.toLowerCase().includes('bitcoin')
          ) {
            return alert("Nope. That's a bad idea.")
          }
    
          if (
            action.type === ADD_GOAL &&
            action.goal.name.toLowerCase().includes('bitcoin')
          ) {
            return alert("Nope. That's a bad idea.")
          }
    
          return next(action)
        }
    
        const logger = (store) => (next) => (action) => {
          console.group(action.type)
            console.log('The action: ', action)
            const result = next(action)
            console.log('The new state: ', store.getState())
          console.groupEnd()
          return result
        }
    
        const store = Redux.createStore(Redux.combineReducers({
          todos,
          goals,
        }), Redux.applyMiddleware(checker, logger))
    
        /*
        With React we dont have to do any of these DOM operations because React does that for us
        it is one of the good thing about using React
        store.subscribe(() => {
          const { goals, todos } = store.getState()
    
          //document.getElementById('goals').innerHTML = ''
          //document.getElementById('todos').innerHTML = ''
    
          //goals.forEach(addGoalToDOM)
          //todos.forEach(addTodoToDOM)
        })*/
    
        // DOM code
        function addTodo () {
          const input = document.getElementById('todo')
          const name = input.value
          input.value = ''
    
          store.dispatch(addTodoAction({
            name,
            complete: false,
            id: generateId()
          }))
        }
    
        function addGoal () {
          const input = document.getElementById('goal')
          const name = input.value
          input.value = ''
    
          store.dispatch(addGoalAction({
            id: generateId(),
            name,
          }))
        }
    
    </script>
    <!-- This lets the compiler to knw when we have babel script code to run-->
    <script type='text/babel'> 
        function List (props) {
          return (
            <ul>
                {props.items.map((item) => (
                    <li key={item.id}>
                        <span>{item.name}</span>
                    </li>
                ))}
            </ul>
          )
        }
    
        class Todos extends React.Component {
            
            addItem = (e) => {

                e.preventDefault()
                const name = this.todoInput.value //we can easily reference this.input with arrow functions here because we assigned an input property to the global this within this component
                this.todoInput.value = ''
                
                //the store was passed as props from the parent, the App Component. We will still break this props down into separete modules later
                //but passing it as props for now makes it easier for refactoring later
                this.props.store.dispatch(addTodoAction({
                    name,
                    complete: false,
                    id: generateId()
                }))
            }
          render() {
            return (
              <div>
                <h1>Todo List</h1>
                <input
                type='text'
                placeholder='Add Todo'
                ref={ /*
                    inputElement is a reference to the input DOM element. We are storing a reference to the input DOM element
                    in the todoInput instance property of the Todos class.
                    Remeber With arrow functions, the value of "this" is based on the function's surrounding context 
                    (where the function is located in the code). In other words, the value of this inside an arrow function 
                    is the same as the value of this outside the function.

                    Instead of sticking the value of this input field on our Component state to make it controlled,
                    We added a ref and stick this ref on this component instance. So whenever, we want
                    to grap the value of the input, we will grap it from 'this.todoInput'

                    for more on when to use refs cehck here https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
                    */
                    (inputElement) => this.todoInput = inputElement}
                />
                <button onClick={this.addItem}>Add Todo</button>
    
                <List items={this.props.todos}/>
              </div>
            )
          }
        }
    
        class Goals extends React.Component {

            addItem = (e) => {
                e.preventDefault()
                const name = this.input.value
                this.input.value = ''

                this.props.store.dispatch(addGoalAction({
                    id: generateId(),
                    name,
                }))
            }

          render() {
            return (
              <div>
                <h1>Goals</h1>
                <input
                type='text'
                placeholder='Add Goal'
                ref={(input) => this.input = input}
                />
                <button onClick={this.addItem}>Add Goal</button>
    
                <List items={this.props.goals}/>
              </div>
            )
          }
        }
    
        class App extends React.Component {

            componentDidMount () {
                const { store } = this.props
                
                store.subscribe(() => this.forceUpdate()) //forceUpdate is an anti-pattern in React. We rearly use it but it works
            }

          render() {

            /*Whenever the forceUpdate gets called we will re-render this component. This is rarely used to re-render components but for our case right here, it fits
            because we dont have a state inside of the App component and it does not make sense to any any just to cause a re-render
            Most of the times, we use this.setState to re-render the UI wheich we are use to*/
            const { store } = this.props
            const { todos, goals } = store.getState() //get the slices of the state tree and pass them down as props to the individual component that needs them which will eventually used to render a list of todos and goals

            return (
              <div>
                <Todos todos={todos} store={/*we get the store props passed to our app component and pass it down to the Todo component*/
                    this.props.store}/>
                <Goals goals={goals} store={this.props.store}/>
              </div>
            )
          }
        }
    
        ReactDOM.render(
          <App store={/*Ideally, we will have our store with the actions and reducers in 
            another file(we will have all the code in <text/javascript> at another file) and we will import it as prop to our app. 
            This way, we are maintaining our state from one place which is the purpose of using Redux*/
              store}/>,
          document.getElementById('app')
        )
      </script>
</body>
</html>